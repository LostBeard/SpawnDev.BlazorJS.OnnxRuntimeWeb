@page "/tests"
@implements IDisposable

<PageTitle>ORT Tests</PageTitle>

<h1>ONNX Runtime Web — Tests</h1>

<div style="margin-bottom: 1rem;">
    <button class="btn btn-primary" @onclick="RunAllTests" disabled="@_running">
        @(_running ? "Running..." : "Run All Tests")
    </button>
</div>

@foreach (var test in _tests)
{
    <div style="padding: 8px 12px; margin: 4px 0; border-radius: 4px;
                background: @(test.Status == TestStatus.Pass ? "#d4edda" :
                              test.Status == TestStatus.Fail ? "#f8d7da" :
                              test.Status == TestStatus.Running ? "#fff3cd" : "#e9ecef");
                color: #333; font-family: monospace; font-size: 14px;">
        <strong>@StatusIcon(test.Status)</strong> @test.Name
        @if (!string.IsNullOrEmpty(test.Detail))
        {
            <br /><span style="margin-left: 28px; font-size: 12px; color: #555;">@test.Detail</span>
        }
    </div>
}

@code {

    [Inject]
    BlazorJSRuntime JS { get; set; } = default!;

    private OnnxRuntime? _ort;
    private bool _running;
    private List<TestItem> _tests = new();

    enum TestStatus { Pending, Running, Pass, Fail }

    class TestItem
    {
        public string Name { get; set; } = "";
        public TestStatus Status { get; set; } = TestStatus.Pending;
        public string? Detail { get; set; }
    }

    string StatusIcon(TestStatus s) => s switch
    {
        TestStatus.Pass => "✅",
        TestStatus.Fail => "❌",
        TestStatus.Running => "⏳",
        _ => "⬜"
    };

    async Task RunAllTests()
    {
        _running = true;
        _tests.Clear();

        // Define all tests
        var t1  = AddTest("1. Module Load");
        var t2  = AddTest("2. Environment Configuration");
        var t3  = AddTest("3. Session Create (simple add model)");
        var t4  = AddTest("4. Tensor Create + Inference");
        var t5  = AddTest("5. Output Verification");
        var t6  = AddTest("6. Tensor Properties");
        var t7  = AddTest("7. Tensor Data Access");
        var t8  = AddTest("8. Tensor Reshape");
        var t9  = AddTest("9. Tensor Dispose");
        var t10 = AddTest("10. Session Metadata");
        var t11 = AddTest("11. Run with Options");
        var t12 = AddTest("12. Multiple Inferences");
        var t13 = AddTest("13. Int32 Tensor");

        StateHasChanged();
        await Task.Delay(50);

        // ── Test 1: Load ORT module ──
        await RunTest(t1, async () =>
        {
            _ort = await OnnxRuntime.Init();
            t1.Detail = $"Module loaded. Tensor class exists: {_ort.TensorClass != null}";
        });

        if (_ort == null) { _running = false; StateHasChanged(); return; }

        // ── Test 2: Environment ──
        await RunTest(t2, async () =>
        {
            using var env = _ort!.Env;
            env.LogSeverityLevel = 2;
            var level = env.LogSeverityLevel;
            if (level != 2) throw new Exception($"LogSeverityLevel expected 2, got {level}");
            t2.Detail = $"LogSeverityLevel set to {level}. Env accessible.";
            await Task.CompletedTask;
        });

        // ── Test 3: Create session from a tiny ONNX model ──
        OrtInferenceSession? session = null;
        await RunTest(t3, async () =>
        {
            var modelBytes = BuildSimpleAddModel();
            using var jsArrayBuffer = new ArrayBuffer(modelBytes.Length);
            using var jsView = new Uint8Array(jsArrayBuffer);
            for (int i = 0; i < modelBytes.Length; i++)
                jsView[i] = modelBytes[i];

            session = await _ort!.CreateInferenceSessionAsync(jsArrayBuffer, new SessionCreateOptions
            {
                LogSeverityLevel = 2
            });

            var inputNames = session.InputNames;
            var outputNames = session.OutputNames;
            t3.Detail = $"Inputs: [{string.Join(", ", inputNames)}], Outputs: [{string.Join(", ", outputNames)}]";

            if (inputNames.Length != 2) throw new Exception($"Expected 2 inputs, got {inputNames.Length}");
            if (outputNames.Length != 1) throw new Exception($"Expected 1 output, got {outputNames.Length}");
        });

        if (session == null) { _running = false; StateHasChanged(); return; }

        // ── Test 4: Create tensors and run inference ──
        OrtSessionResult? result = null;
        await RunTest(t4, async () =>
        {
            using var dataA = new Float32Array(new float[] { 1f, 2f, 3f });
            using var dataB = new Float32Array(new float[] { 4f, 5f, 6f });

            using var tensorA = new OrtTensor("float32", dataA, new long[] { 1, 3 });
            using var tensorB = new OrtTensor("float32", dataB, new long[] { 1, 3 });

            t4.Detail = $"Input A dims: [{string.Join(",", tensorA.Dims)}], type: {tensorA.Type}";

            using var feeds = new OrtFeeds();
            var inputNames = session!.InputNames;
            feeds.Set(inputNames[0], tensorA);
            feeds.Set(inputNames[1], tensorB);

            result = await session.Run(feeds, new SessionRunOptions { LogSeverityLevel = 2 });
            t4.Detail += $" → Output received";
        });

        if (result == null) { _running = false; StateHasChanged(); return; }

        // ── Test 5: Verify output values ──
        await RunTest(t5, async () =>
        {
            var outputName = session!.OutputNames[0];
            using var outputTensor = result!.GetTensor(outputName);

            var dims = outputTensor.Dims;
            var type = outputTensor.Type;
            var location = outputTensor.Location;

            t5.Detail = $"Dims: [{string.Join(",", dims)}], Type: {type}, Location: {location}";

            using var outputData = outputTensor.GetData<Float32Array>();
            var values = new float[outputData.Length];
            for (int i = 0; i < outputData.Length; i++)
                values[i] = outputData[i];

            float[] expected = { 5f, 7f, 9f };
            for (int i = 0; i < expected.Length; i++)
            {
                if (Math.Abs(values[i] - expected[i]) > 0.001f)
                    throw new Exception($"Output[{i}] expected {expected[i]}, got {values[i]}");
            }

            t5.Detail += $" → Values: [{string.Join(", ", values)}] ✓";
            await Task.CompletedTask;
        });

        // Cleanup result from test 4-5
        result?.Dispose();

        // ── Test 6: Tensor Properties ──
        await RunTest(t6, async () =>
        {
            using var data = new Float32Array(new float[] { 10f, 20f, 30f, 40f, 50f, 60f });
            using var tensor = new OrtTensor("float32", data, new long[] { 2, 3 });

            var dims = tensor.Dims;
            var type = tensor.Type;
            var size = tensor.Size;
            var location = tensor.Location;

            if (dims.Length != 2) throw new Exception($"Expected 2 dims, got {dims.Length}");
            if (dims[0] != 2 || dims[1] != 3) throw new Exception($"Expected dims [2,3], got [{string.Join(",", dims)}]");
            if (type != "float32") throw new Exception($"Expected type float32, got {type}");
            if (size != 6) throw new Exception($"Expected size 6, got {size}");
            if (location != "cpu") throw new Exception($"Expected location cpu, got {location}");

            t6.Detail = $"Dims: [{string.Join(",", dims)}], Type: {type}, Size: {size}, Location: {location} ✓";
            await Task.CompletedTask;
        });

        // ── Test 7: Tensor Data Access ──
        await RunTest(t7, async () =>
        {
            var srcValues = new float[] { 1.5f, 2.5f, 3.5f };
            using var data = new Float32Array(srcValues);
            using var tensor = new OrtTensor("float32", data, new long[] { 3 });

            // Synchronous data access (CPU tensor)
            using var readBack = tensor.GetData<Float32Array>();
            for (int i = 0; i < srcValues.Length; i++)
            {
                if (Math.Abs(readBack[i] - srcValues[i]) > 0.001f)
                    throw new Exception($"Sync data[{i}] expected {srcValues[i]}, got {readBack[i]}");
            }

            // Async data access
            using var asyncData = await tensor.GetDataAsync<Float32Array>();
            for (int i = 0; i < srcValues.Length; i++)
            {
                if (Math.Abs(asyncData[i] - srcValues[i]) > 0.001f)
                    throw new Exception($"Async data[{i}] expected {srcValues[i]}, got {asyncData[i]}");
            }

            t7.Detail = $"Sync read: [{string.Join(", ", srcValues)}], Async read: OK ✓";
        });

        // ── Test 8: Tensor Reshape ──
        await RunTest(t8, async () =>
        {
            using var data = new Float32Array(new float[] { 1f, 2f, 3f, 4f, 5f, 6f });
            using var tensor = new OrtTensor("float32", data, new long[] { 2, 3 });

            using var reshaped = tensor.Reshape(new long[] { 3, 2 });

            var newDims = reshaped.Dims;
            if (newDims[0] != 3 || newDims[1] != 2)
                throw new Exception($"Expected dims [3,2], got [{string.Join(",", newDims)}]");

            // Verify data is preserved
            using var reshapedData = reshaped.GetData<Float32Array>();
            if (Math.Abs(reshapedData[0] - 1f) > 0.001f || Math.Abs(reshapedData[5] - 6f) > 0.001f)
                throw new Exception("Reshape changed data values");

            t8.Detail = $"[2,3] → [{string.Join(",", newDims)}], data preserved ✓";
            await Task.CompletedTask;
        });

        // ── Test 9: Tensor Dispose ──
        await RunTest(t9, async () =>
        {
            using var data = new Float32Array(new float[] { 1f, 2f });
            var tensor = new OrtTensor("float32", data, new long[] { 2 });

            var locationBefore = tensor.Location;
            tensor.DisposeData();
            var locationAfter = tensor.Location;

            if (locationBefore != "cpu") throw new Exception($"Before dispose: expected 'cpu', got '{locationBefore}'");
            if (locationAfter != "none") throw new Exception($"After dispose: expected 'none', got '{locationAfter}'");

            t9.Detail = $"Before: {locationBefore} → After: {locationAfter} ✓";
            tensor.Dispose();
            await Task.CompletedTask;
        });

        // ── Test 10: Session Metadata ──
        await RunTest(t10, async () =>
        {
            using var inputMeta = session!.InputMetadata;
            using var outputMeta = session!.OutputMetadata;

            if (inputMeta == null) throw new Exception("InputMetadata is null");
            if (outputMeta == null) throw new Exception("OutputMetadata is null");

            t10.Detail = $"InputMetadata: present, OutputMetadata: present ✓";
            await Task.CompletedTask;
        });

        // ── Test 11: Run with Options ──
        await RunTest(t11, async () =>
        {
            using var dataA = new Float32Array(new float[] { 10f, 20f, 30f });
            using var dataB = new Float32Array(new float[] { 1f, 2f, 3f });
            using var tensorA = new OrtTensor("float32", dataA, new long[] { 1, 3 });
            using var tensorB = new OrtTensor("float32", dataB, new long[] { 1, 3 });

            using var feeds = new OrtFeeds();
            feeds.Set("A", tensorA);
            feeds.Set("B", tensorB);

            var options = new SessionRunOptions
            {
                LogSeverityLevel = 3,
                Tag = "test-run-11"
            };

            using var runResult = await session!.Run(feeds, options);
            using var output = runResult.GetTensor("C");
            using var outData = output.GetData<Float32Array>();

            float[] expected = { 11f, 22f, 33f };
            for (int i = 0; i < expected.Length; i++)
            {
                if (Math.Abs(outData[i] - expected[i]) > 0.001f)
                    throw new Exception($"Output[{i}] expected {expected[i]}, got {outData[i]}");
            }

            t11.Detail = $"Run with tag='{options.Tag}', severity={options.LogSeverityLevel} → [{string.Join(", ", expected)}] ✓";
        });

        // ── Test 12: Multiple Inferences ──
        await RunTest(t12, async () =>
        {
            var allCorrect = true;
            var runs = new[] {
                (new float[] { 1f, 1f, 1f }, new float[] { 2f, 2f, 2f }, new float[] { 3f, 3f, 3f }),
                (new float[] { 0f, 0f, 0f }, new float[] { 0f, 0f, 0f }, new float[] { 0f, 0f, 0f }),
                (new float[] { -1f, 5f, 10f }, new float[] { 1f, -5f, -10f }, new float[] { 0f, 0f, 0f })
            };

            for (int r = 0; r < runs.Length; r++)
            {
                var (aVals, bVals, expectedVals) = runs[r];
                using var dA = new Float32Array(aVals);
                using var dB = new Float32Array(bVals);
                using var tA = new OrtTensor("float32", dA, new long[] { 1, 3 });
                using var tB = new OrtTensor("float32", dB, new long[] { 1, 3 });
                using var f = new OrtFeeds();
                f.Set("A", tA);
                f.Set("B", tB);

                using var res = await session!.Run(f);
                using var outT = res.GetTensor("C");
                using var outD = outT.GetData<Float32Array>();

                for (int i = 0; i < 3; i++)
                {
                    if (Math.Abs(outD[i] - expectedVals[i]) > 0.001f)
                    {
                        allCorrect = false;
                        throw new Exception($"Run {r + 1}: Output[{i}] expected {expectedVals[i]}, got {outD[i]}");
                    }
                }
            }

            t12.Detail = $"3 consecutive runs, all correct ✓";
        });

        // ── Test 13: Int32 Tensor ──
        await RunTest(t13, async () =>
        {
            // Create a simple int32 add model
            var modelBytes = BuildSimpleAddModel(elemType: 6); // 6 = INT32
            using var jsArrayBuffer = new ArrayBuffer(modelBytes.Length);
            using var jsView = new Uint8Array(jsArrayBuffer);
            for (int i = 0; i < modelBytes.Length; i++)
                jsView[i] = modelBytes[i];

            using var intSession = await _ort!.CreateInferenceSessionAsync(jsArrayBuffer, new SessionCreateOptions
            {
                LogSeverityLevel = 2
            });

            using var dataA = new Int32Array(new int[] { 100, 200, 300 });
            using var dataB = new Int32Array(new int[] { 10, 20, 30 });
            using var tensorA = new OrtTensor("int32", dataA, new long[] { 1, 3 });
            using var tensorB = new OrtTensor("int32", dataB, new long[] { 1, 3 });

            using var feeds = new OrtFeeds();
            feeds.Set("A", tensorA);
            feeds.Set("B", tensorB);

            using var intResult = await intSession.Run(feeds);
            using var output = intResult.GetTensor("C");

            if (output.Type != "int32") throw new Exception($"Expected type int32, got {output.Type}");

            using var outData = output.GetData<Int32Array>();
            int[] expected = { 110, 220, 330 };
            for (int i = 0; i < expected.Length; i++)
            {
                if (outData[i] != expected[i])
                    throw new Exception($"Int32 Output[{i}] expected {expected[i]}, got {outData[i]}");
            }

            t13.Detail = $"Type: {output.Type}, Dims: [{string.Join(",", output.Dims)}] → [{string.Join(", ", expected)}] ✓";
            await intSession.Release();
        });

        // Cleanup
        session?.Dispose();

        _running = false;
        StateHasChanged();
    }

    TestItem AddTest(string name)
    {
        var t = new TestItem { Name = name };
        _tests.Add(t);
        return t;
    }

    async Task RunTest(TestItem test, Func<Task> action)
    {
        test.Status = TestStatus.Running;
        StateHasChanged();
        await Task.Delay(20);

        try
        {
            await action();
            test.Status = TestStatus.Pass;
        }
        catch (Exception ex)
        {
            test.Status = TestStatus.Fail;
            test.Detail = ex.Message;
            Console.WriteLine($"TEST FAIL [{test.Name}]: {ex}");
        }

        StateHasChanged();
        await Task.Delay(20);
    }

    /// <summary>
    /// Build a minimal ONNX protobuf for Add(A, B) -> C
    /// ONNX is protobuf-based. This builds the binary manually.
    /// </summary>
    /// <param name="elemType">ONNX element type: 1=FLOAT, 6=INT32, 7=INT64, etc.</param>
    static byte[] BuildSimpleAddModel(int elemType = 1)
    {
        // This is a hand-crafted minimal ONNX protobuf for:
        //   inputs: A (type, [1,3]), B (type, [1,3])
        //   outputs: C (type, [1,3])
        //   nodes: C = Add(A, B)
        //   opset: 13
        using var ms = new System.IO.MemoryStream();
        using var w = new System.IO.BinaryWriter(ms);

        // Helper to write protobuf varint
        void WriteVarint(ulong value)
        {
            while (value >= 0x80)
            {
                w.Write((byte)(value | 0x80));
                value >>= 7;
            }
            w.Write((byte)value);
        }

        // Helper to write a protobuf field tag
        void WriteTag(int fieldNumber, int wireType)
        {
            WriteVarint((ulong)((fieldNumber << 3) | wireType));
        }

        // Helper to write length-delimited field
        void WriteLenField(int fieldNumber, byte[] data)
        {
            WriteTag(fieldNumber, 2); // wire type 2 = length-delimited
            WriteVarint((ulong)data.Length);
            w.Write(data);
        }

        void WriteStringField(int fieldNumber, string s)
        {
            var bytes = System.Text.Encoding.UTF8.GetBytes(s);
            WriteLenField(fieldNumber, bytes);
        }

        void WriteVarintField(int fieldNumber, long value)
        {
            WriteTag(fieldNumber, 0); // wire type 0 = varint
            WriteVarint((ulong)value);
        }

        // Build TensorTypeProto for given elemType [1,3]
        byte[] BuildTensorType()
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);

            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }
            void SubWriteVarintField(int fn, long v) { SubWriteTag(fn, 0); SubWriteVarint((ulong)v); }

            // elem_type - field 1
            SubWriteVarintField(1, elemType);

            // shape - field 2 (TensorShapeProto)
            byte[] BuildDim(long val)
            {
                using var ds = new System.IO.MemoryStream();
                using var dw = new System.IO.BinaryWriter(ds);
                void DWriteVarint(ulong v2) { while (v2 >= 0x80) { dw.Write((byte)(v2 | 0x80)); v2 >>= 7; } dw.Write((byte)v2); }
                void DWriteTag(int fn, int wt) { DWriteVarint((ulong)((fn << 3) | wt)); }
                void DWriteVarintField(int fn, long v2) { DWriteTag(fn, 0); DWriteVarint((ulong)v2); }
                DWriteVarintField(1, val); // dim_value = field 1
                return ds.ToArray();
            }

            byte[] BuildShape()
            {
                using var ss = new System.IO.MemoryStream();
                using var ssw = new System.IO.BinaryWriter(ss);
                void SWriteVarint(ulong v3) { while (v3 >= 0x80) { ssw.Write((byte)(v3 | 0x80)); v3 >>= 7; } ssw.Write((byte)v3); }
                void SWriteTag(int fn, int wt) { SWriteVarint((ulong)((fn << 3) | wt)); }
                void SWriteLenField(int fn, byte[] d) { SWriteTag(fn, 2); SWriteVarint((ulong)d.Length); ssw.Write(d); }
                var dim1 = BuildDim(1);
                var dim3 = BuildDim(3);
                SWriteLenField(1, dim1); // dim - field 1 (repeated)
                SWriteLenField(1, dim3);
                return ss.ToArray();
            }

            SubWriteLenField(2, BuildShape());
            return sub.ToArray();
        }

        // Build TypeProto containing tensor_type
        byte[] BuildTypeProto()
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);
            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }
            SubWriteLenField(1, BuildTensorType()); // tensor_type = field 1
            return sub.ToArray();
        }

        // Build ValueInfoProto
        byte[] BuildValueInfo(string name)
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);
            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }
            var nameBytes = System.Text.Encoding.UTF8.GetBytes(name);
            SubWriteLenField(1, nameBytes); // name = field 1
            SubWriteLenField(2, BuildTypeProto()); // type = field 2
            return sub.ToArray();
        }

        // Build NodeProto for Add
        byte[] BuildAddNode()
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);
            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }
            SubWriteLenField(1, System.Text.Encoding.UTF8.GetBytes("A")); // input - field 1 (repeated)
            SubWriteLenField(1, System.Text.Encoding.UTF8.GetBytes("B")); // input
            SubWriteLenField(2, System.Text.Encoding.UTF8.GetBytes("C")); // output - field 2 (repeated)
            SubWriteLenField(3, System.Text.Encoding.UTF8.GetBytes("add_node")); // name - field 3
            SubWriteLenField(4, System.Text.Encoding.UTF8.GetBytes("Add")); // op_type - field 4
            return sub.ToArray();
        }

        // Build GraphProto
        byte[] BuildGraph()
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);
            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }

            SubWriteLenField(1, BuildAddNode()); // node - field 1 (repeated)
            SubWriteLenField(2, System.Text.Encoding.UTF8.GetBytes("test_graph")); // name - field 2
            SubWriteLenField(11, BuildValueInfo("A")); // input - field 11 (repeated)
            SubWriteLenField(11, BuildValueInfo("B")); // input
            SubWriteLenField(12, BuildValueInfo("C")); // output - field 12 (repeated)

            return sub.ToArray();
        }

        // Build OperatorSetIdProto
        byte[] BuildOpsetImport()
        {
            using var sub = new System.IO.MemoryStream();
            using var sw = new System.IO.BinaryWriter(sub);
            void SubWriteVarint(ulong v) { while (v >= 0x80) { sw.Write((byte)(v | 0x80)); v >>= 7; } sw.Write((byte)v); }
            void SubWriteTag(int fn, int wt) { SubWriteVarint((ulong)((fn << 3) | wt)); }
            void SubWriteLenField(int fn, byte[] d) { SubWriteTag(fn, 2); SubWriteVarint((ulong)d.Length); sw.Write(d); }
            void SubWriteVarintField(int fn, long v) { SubWriteTag(fn, 0); SubWriteVarint((ulong)v); }
            SubWriteLenField(1, System.Text.Encoding.UTF8.GetBytes("")); // domain - field 1
            SubWriteVarintField(2, 13); // version = 13 - field 2
            return sub.ToArray();
        }

        // Build ModelProto (the top-level message)
        WriteVarintField(1, 7); // ir_version = 7
        WriteLenField(8, BuildOpsetImport()); // opset_import
        WriteLenField(7, BuildGraph()); // graph

        return ms.ToArray();
    }

    public void Dispose()
    {
        _ort?.Dispose();
    }
}
